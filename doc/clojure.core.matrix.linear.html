<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clojure.core.matrix.linear documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Core.matrix</span> <span class="project-version">0.44.0</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3"><a href="clojure.core.matrix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.implementations.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>implementations</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-4 branch current"><a href="clojure.core.matrix.linear.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linear</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.operators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.select.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select</span></div></a></li><li class="depth-4"><a href="clojure.core.matrix.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-cholesky"><div class="inner"><span>cholesky</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-eigen"><div class="inner"><span>eigen</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-least-squares"><div class="inner"><span>least-squares</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-lu"><div class="inner"><span>lu</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-norm"><div class="inner"><span>norm</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-qr"><div class="inner"><span>qr</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-rank"><div class="inner"><span>rank</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-solve"><div class="inner"><span>solve</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.linear.html#var-svd"><div class="inner"><span>svd</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clojure.core.matrix.linear</h1><div class="doc"><pre class="plaintext">Namespace for core.matrix linear algebra API.

These function complement the main core.matrix API with specialised functions for linear
algebra operations.</pre></div><div class="public anchor" id="var-cholesky"><h3>cholesky</h3><div class="usage"><code>(cholesky m options)</code><code>(cholesky m)</code></div><div class="doc"><pre class="plaintext">Computes the Cholesky decomposition of a hermitian, positive definite matrix.
Returns a map containing two matrices with the keys [:L :L*] such that

Such that:
  M = L.L*

Where
  - M must be a hermitian, positive definite matrix
  - L is a lower triangular matrix
  - L* is the conjugate transpose of L

If :return parameter is specified in options map, it returns only specified keys.

Intended usage: (let [{:keys [L L*]} (cholesky M)] ....)
                (let [{:keys [L*]} (cholesky M {:return [:L*]})] ....)</pre></div></div><div class="public anchor" id="var-eigen"><h3>eigen</h3><div class="usage"><code>(eigen m options)</code><code>(eigen m)</code></div><div class="doc"><pre class="plaintext">Computes the Eigen decomposition of a diagonalisable matrix.
Returns a map containing matrices for each of the the keys [:Q :A] such that:

   M l= Q.A.Q&lt;sup&gt;-1&lt;/sup&gt;

Where:
  - Q is a matrix where each column is the ith normalised eigenvector of M
  - A is a diagonal matrix whose diagonal elements are the eigenvalues.
  - Q&lt;sup&gt;-1&lt;/sup&gt; is the inverse of Q

If :return parameter is specified in options map, it returns only specified keys.

Intended usage: (let [{:keys [Q A]} (eigen M)] ....)
                (let [{:keys [A]} (eigen M {:return [:A]})] ....)</pre></div></div><div class="public anchor" id="var-least-squares"><h3>least-squares</h3><div class="usage"><code>(least-squares a b)</code></div><div class="doc"><pre class="plaintext">Computes least-squares solution to a linear matrix equation.

Intended usage: (let [X (least-squares A B)] ....)</pre></div></div><div class="public anchor" id="var-lu"><h3>lu</h3><div class="usage"><code>(lu m options)</code><code>(lu m)</code></div><div class="doc"><pre class="plaintext">Computes the LU(P) decomposition of a matrix with partial row pivoting.
Returns a map containing the keys [:L :U :P], such that:
  P.A = L.U

Where
  - L is a lower triangular matrix
  - U is an upper triangular matrix
  - P is a permutation matrix

If :return parameter is specified in options map, it returns only specified keys.

Intended usage: (let [{:keys [L U P]} (lu A)] ....)
                (let [{:keys [L U]} (lu M {:return [:L :U]})] ....)</pre></div></div><div class="public anchor" id="var-norm"><h3>norm</h3><div class="usage"><code>(norm m)</code><code>(norm m p)</code></div><div class="doc"><pre class="plaintext">Computes the norm of a matrix or vector.

By default calculates 2-norm for vectors and Frobenius 2-norm for matrices. The optional p argument specifies use of the p-norm instead.

Special cases of p argument:
Double/POSITIVE_INFINITY - Infinity norm

Intended usage: (let [n (norm v 1)] ....)
                (let [n (norm v Double/POSITIVE_INFINITY)] ....)
                (let [n (norm v)] ....)</pre></div></div><div class="public anchor" id="var-qr"><h3>qr</h3><div class="usage"><code>(qr m {:keys [return compact], :or {return [:Q :R], compact false}})</code><code>(qr m)</code></div><div class="doc"><pre class="plaintext">Computes QR decomposition of a full rank matrix.
Returns a map containing matrices of an input matrix type with the keys [:Q :R] such that:
     M = Q.R

Where:
 - Q is an orthogonal matrix
 - R is an upper triangular matrix (= right triangular matrix)
If :return parameter is specified in options map, it returns only specified keys.
If :compact parameter is specified in options map, compact versions of matrices are returned.

Returns nil if decomposition is impossible.

Intended usage: (let [{:keys [Q R]} (qr M)] ....)
                (let [{:keys [R]} (qr M {:return [:R]})] ....)</pre></div></div><div class="public anchor" id="var-rank"><h3>rank</h3><div class="usage"><code>(rank m)</code></div><div class="doc"><pre class="plaintext">Computes the rank of a matrix, i.e. the number of linearly independent rows.

Intended usage: (let [r (rank m)] ....)</pre></div></div><div class="public anchor" id="var-solve"><h3>solve</h3><div class="usage"><code>(solve a b)</code><code>(solve a)</code></div><div class="doc"><pre class="plaintext">Solves a linear matrix equation, or system of linear scalar equations, i.e. finds the
value X such that:

  A.X = B

Where:
  - A is a square matrix containing the coefficients of the linear system
  - B is a vector containing the right-hand side of the linear system.
If B is missing, it is taken as an identity matrix and returns inverse of A

Intended usage: (let [X (solve A B)] ....)</pre></div></div><div class="public anchor" id="var-svd"><h3>svd</h3><div class="usage"><code>(svd m options)</code><code>(svd m)</code></div><div class="doc"><pre class="plaintext">Computes the Singular Value decomposition of a matrix.
Returns a map containing the keys [:U :S :V*] such that:
  M = U.S.V*

Where
  - U is an unitary matrix
  - S is a diagonal matrix whose elements are the singular values of the original matrix
  - V* is an unitary matrix

If :return parameter is specified in options map, it returns only specified keys.

Intended usage: (let [{:keys [U S V*]} (svd M)] ....)
                (let [{:keys [S]} (svd M {:return [:S]})] ....)</pre></div></div></div></body></html>